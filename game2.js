// Generated by CoffeeScript 1.6.3
(function() {
  var BLOCK_SIZE, FACE_DELAY, Game, Level, random_color;

  random_color = function() {
    return "#" + Math.floor(Math.random() * 16777215).toString(16);
  };

  Game = function() {
    window.Q = Quintus({
      development: true
    }).include("Sprites, Scenes, 2D, Input, UI").setup({
      maximize: true
    });
    Q.Sprite.extend("Player", {
      init: function(p) {
        this._super(p, {
          asset: Game.Assets.monster_faces[0],
          hitPoints: 10,
          damage: 5,
          x: BLOCK_SIZE,
          y: BLOCK_SIZE,
          face_count: FACE_DELAY,
          current_face: 0,
          faces: Game.Assets.monster_faces,
          angle: -5,
          points: [[-50, -50], [40, -50], [40, 40], [-50, 40]],
          salto: 0,
          score: 0,
          scroll_up: 0,
          speed_wakkel: false
        });
        this.update_face();
        return this.add("2d, platformerControls");
      },
      step: function() {
        this.p.face_count -= 1;
        if (this.p.speed_wakkel || this.p.face_count < 0 && this.p.salto === 0) {
          this.p.angle *= -1;
        }
        if (this.p.salto > 0) {
          this.p.angle = this.p.salto;
          this.p.salto -= 5;
        }
        if (this.p.face_count < 0) {
          this.p.face_count = FACE_DELAY;
          this.next_face();
        }
        if (this.p.y > Q.height && this.p.scroll_up <= 0) {
          this.p.scroll_up = BLOCK_SIZE * 3;
        }
        if (this.p.scroll_up > 0) {
          this.p.scroll_up -= 4;
          Q('Block').each(function() {
            return this.p.y -= 4;
          });
          Q('Player').each(function() {
            return this.p.y -= 4;
          });
          return Q('Ruby').each(function() {
            return this.p.y -= 4;
          });
        }
      },
      next_face: function() {
        this.p.current_face += 1;
        if (this.p.current_face >= this.p.faces.length) {
          this.p.current_face = 0;
        }
        return this.update_face();
      },
      update_face: function() {
        return this.p.asset = this.p.faces[this.p.current_face];
      },
      salto: function() {
        if (this.p.salto < 360) {
          this.p.salto += 360;
        }
        return this.p.vy = -600;
      },
      inc_score: function() {
        this.p.score += 1;
        return Game.score_label.p.label = '' + this.p.score;
      },
      collect_gem: function() {
        var undo_wakkel,
          _this = this;
        this.inc_score();
        this.p.angle = -7;
        this.p.speed_wakkel = true;
        undo_wakkel = function() {
          _this.p.angle = 5;
          return _this.p.speed_wakkel = false;
        };
        return setTimeout(undo_wakkel, 1000);
      }
    });
    Q.Sprite.extend("Ruby", {
      init: function(p) {
        console.log(Game.Assets.rubyred);
        this._super(p, {
          asset: Game.Assets.rubyred
        });
        this.add("2d");
        return this.on("hit", this, "collision");
      },
      collision: function(coll) {
        if (coll.obj.isA('Player')) {
          coll.obj.collect_gem();
          return this.destroy();
        }
      }
    });
    Q.Sprite.extend("Block", {
      init: function(p) {
        return this._super(p, {
          color: random_color(),
          w: BLOCK_SIZE,
          h: BLOCK_SIZE
        });
      },
      draw: function(ctx) {
        ctx.fillStyle = this.p.color;
        return ctx.fillRect(-this.p.cx, -this.p.cy, this.p.w, this.p.h);
      }
    });
    Q.scene("start", function(stage) {
      var build_world, player, y;
      player = new Q.Player({
        stage: stage
      });
      stage.insert(player);
      y = 0;
      Game.score_label = stage.insert(new Q.UI.Text({
        x: Q.width - 250,
        y: 100,
        scale: 3,
        label: '0'
      }));
      build_world = function() {
        var block, char, row, ruby, x, _results;
        _results = [];
        while (y < Level.length) {
          row = Level[y];
          x = 0;
          while (x < row.length) {
            char = row.charAt(x);
            if (char === "x") {
              block = new Q.Block({
                x: (x + 0.5) * BLOCK_SIZE,
                y: (y + 0.5) * BLOCK_SIZE
              });
              stage.insert(block);
            }
            if (char === "." && Math.random() < 0.2) {
              ruby = new Q.Ruby({
                x: (x + 0.5) * BLOCK_SIZE,
                y: (y + 0.5) * BLOCK_SIZE
              });
              stage.insert(ruby);
            }
            x++;
          }
          _results.push(y++);
        }
        return _results;
      };
      build_world();
      return Q.input.on('fire', stage, function(e) {
        return player.salto();
      });
    });
    return Q.load(Game.Assets.all, function() {
      Q.stageScene("start");
      return Q.input.keyboardControls();
    });
  };

  Level = ["......          .", "xx xxx      ....x", ".   ......  xxxxx", "    xxxxxx  ", "...... . x.....x", "xx xxx   xxxxx.x ", "..     .   ....x", "xx   ..x.. xxxxx", ".    xx.xx ", "........... xxxx", "xxxxxx   xxxxxx", "x.............x", "x    xx  xx   x", "x      xx     x ", "x.............x ", "xxxxxxxxxxxxxxx"];

  FACE_DELAY = 8;

  BLOCK_SIZE = 100;

  Game.Assets = {
    monster1: "monster1.png",
    monster2: "monster2.png",
    monster3: "monster3.png",
    rubyred: "rubyred.png",
    rubygreen: "rubygreen.png",
    rubyblue: "rubyblue.png"
  };

  Game.Assets.monster_faces = [Game.Assets.monster1, Game.Assets.monster2];

  Game.Assets.rubies = [Game.Assets.rubyred, Game.Assets.rubygreen, Game.Assets.rubyblue];

  Game.Assets.all = Game.Assets.monster_faces.concat(Game.Assets.rubies);

  window.addEventListener("load", Game);

}).call(this);
